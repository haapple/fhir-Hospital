const path = require('path');
require('dotenv').config({ path: path.join(__dirname, '.env') });

const express = require('express');
const cookieParser = require('cookie-parser');
const fetch = (...args) => import('node-fetch').then(({ default: fetch }) => fetch(...args));
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const sendResetEmail = require('./sendResetEmail.js');

// æ·»åŠ  CORS
const cors = require('cors');

const app = express();

// å•Ÿç”¨ä¿¡ä»»ä»£ç†ï¼ˆé‡è¦ï¼ç”¨æ–¼è™•ç†åå‘ä»£ç†å¾Œçš„ HTTPSï¼‰
app.set('trust proxy', true);

// CORS é…ç½® - æ™ºæ…§ç‰ˆ
const corsOptions = {
  origin: function (origin, callback) {
    // å…è¨±çš„åŸŸååˆ—è¡¨
    const allowedOrigins = [
      'http://localhost:3000',
      'http://127.0.0.1:3000',
      'http://localhost',
      'http://127.0.0.1',
      'http://203.64.84.209:3000',
      'http://203.64.84.209',
      'https://203.64.84.209:3000',
      'https://203.64.84.209',
      // æ·»åŠ å¸¸è¦‹çš„å…§ç¶² IP æ®µ
      'http://192.168.0.1:3000',
      'http://192.168.1.1:3000',
      'http://10.0.0.1:3000',
      'http://172.16.0.1:3000'
    ];
    
    // å…è¨±æ²’æœ‰ origin çš„è«‹æ±‚ï¼ˆç›´æ¥ IP è¨ªå•ã€Postman ç­‰ï¼‰
    if (!origin) {
      console.log('ğŸ“¡ å…è¨±ç„¡ origin è«‹æ±‚ï¼ˆç›´æ¥è¨ªå•ï¼‰');
      return callback(null, true);
    }
    
    // æª¢æŸ¥æ˜¯å¦åœ¨å…è¨±åˆ—è¡¨ä¸­
    if (allowedOrigins.indexOf(origin) !== -1) {
      console.log(`âœ… å…è¨±çš„ä¾†æº: ${origin}`);
      return callback(null, true);
    }
    
    // å‹•æ…‹å…è¨±é–‹ç™¼ç’°å¢ƒçš„æ‰€æœ‰è«‹æ±‚
    const isDevelopment = process.env.NODE_ENV !== 'production';
    if (isDevelopment) {
      console.log(`ğŸ”§ é–‹ç™¼ç’°å¢ƒå…è¨±ä¾†æº: ${origin}`);
      return callback(null, true);
    }
    
    // ç”Ÿç”¢ç’°å¢ƒï¼šæª¢æŸ¥æ˜¯å¦ç‚ºåŒåŸŸåä¸åŒç«¯å£
    const originHostname = new URL(origin).hostname;
    const serverHostname = process.env.SERVER_HOSTNAME || '203.64.84.209';
    
    if (originHostname === serverHostname) {
      console.log(`ğŸŒ åŒåŸŸåä¸åŒç«¯å£å…è¨±: ${origin}`);
      return callback(null, true);
    }
    
    console.log('âŒ è¢« CORS é˜»æ“‹çš„ä¾†æº:', origin);
    callback(new Error('ä¸å…è¨±çš„ä¾†æº'));
  },
  credentials: true, // å…è¨±æ”œå¸¶æ†‘è­‰ï¼ˆCookieï¼‰
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization', 'Cookie', 'X-Requested-With'],
  exposedHeaders: ['Set-Cookie'],
  maxAge: 86400 // é æª¢è«‹æ±‚ç·©å­˜æ™‚é–“ï¼ˆ24å°æ™‚ï¼‰
};

app.use(cors(corsOptions));

// è§£æ JSON å’Œ cookie
app.use(express.json({ type: ['application/json', 'application/fhir+json'] }));
app.use(cookieParser());

// â”€â”€ Constants â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const JWT_SECRET = process.env.JWT_SECRET || 'your_fhir_secret_123';
const FHIR_BASE = process.env.FHIR_BASE || 'http://203.64.84.209:8080/fhir';
const LOGIN_ID_SYSTEM = 'http://example.org/fhir/login-id';
const EMAIL_SYSTEM = 'http://example.org/fhir/email';
const PASSWORD_SYSTEM = 'http://example.org/fhir/password';
const LAST_RESET_TIME_SYSTEM = 'http://example.org/fhir/last-reset-time';
const IDENTIFIER_SYSTEMS = [LOGIN_ID_SYSTEM, EMAIL_SYSTEM];

// å­˜å„²å·²ä½¿ç”¨çš„ä»¤ç‰Œ
const usedTokens = new Set();
const activeSessions = new Map();

// â”€â”€ Utility Functions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const handleFHIRResponse = async (response, operation = 'FHIR operation') => {
  if (!response.ok) {
    const errorText = await response.text();
    console.error(`FHIR ${operation} failed:`, response.status, errorText);
    
    if (response.status === 400) {
      throw new Error(`è³‡æ–™æ ¼å¼éŒ¯èª¤: ${errorText}`);
    } else if (response.status === 404) {
      throw new Error('è³‡æºä¸å­˜åœ¨');
    } else if (response.status === 409) {
      throw new Error('è³‡æºè¡çªæˆ–å·²å­˜åœ¨');
    } else {
      throw new Error(`FHIR API éŒ¯èª¤ (${response.status}): ${errorText}`);
    }
  }
  return await response.json();
};

// æ™ºæ…§ Cookie è¨­ç½®å‡½æ•¸
const setSmartCookie = (res, name, value, options = {}) => {
  const defaultOptions = {
    httpOnly: name === 'token', // åªæœ‰ token è¨­ç‚º httpOnly
    maxAge: 3600000, // 1å°æ™‚
    sameSite: 'lax',
    // æ™ºæ…§åˆ¤æ–· secure
    secure: false, // é è¨­ç‚º falseï¼Œè®“æ‰€æœ‰ç’°å¢ƒéƒ½èƒ½ç”¨
    // é‡è¦ï¼šä¸è¨­ç½® domainï¼Œè®“ç€è¦½å™¨è‡ªå‹•è™•ç†
  };
  
  const cookieOptions = { ...defaultOptions, ...options };
  
  console.log(`ğŸª è¨­ç½® Cookie: ${name}, secure=${cookieOptions.secure}, httpOnly=${cookieOptions.httpOnly}`);
  
  res.cookie(name, value, cookieOptions);
  return cookieOptions;
};

// è¼¸å…¥æ¸…ç†å‡½æ•¸
const sanitizeInput = (input) => {
  if (input === null || input === undefined) return '';
  if (typeof input !== 'string') return String(input).trim();
  
  return input
    .trim()
    .replace(/[<>&"']/g, '')
    .substring(0, 255);
};

// é›»å­éƒµä»¶é©—è­‰
const isValidEmail = (email) => {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
};

// â”€â”€ Debug Middleware â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
app.use((req, res, next) => {
  const requestId = Date.now() + Math.random().toString(36).substr(2, 9);
  
  console.log(`\n[${new Date().toISOString()}] [${requestId}] ${req.method} ${req.url}`);
  console.log('  Origin:', req.headers.origin || 'ç„¡');
  console.log('  Host:', req.headers.host);
  console.log('  X-Forwarded-Proto:', req.headers['x-forwarded-proto']);
  console.log('  Cookies:', Object.keys(req.cookies).length > 0 ? req.cookies : 'ç„¡');
  console.log('  Secure:', req.secure);
  console.log('  Protocol:', req.protocol);
  
  req.requestId = requestId;
  next();
});

// â”€â”€ Static Files â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
app.use(express.static(path.join(__dirname, 'public')));

// ç¢ºä¿éœæ…‹è·¯ç”±æ­£ç¢ºå°å‘
app.get('/', (req, res) => res.redirect('/login.html'));
app.get('/login.html', (req, res) => res.sendFile(path.join(__dirname, 'public', 'login.html')));
app.get('/forgot.html', (req, res) => res.sendFile(path.join(__dirname, 'public', 'forgot.html')));
app.get('/register.html', (req, res) => res.sendFile(path.join(__dirname, 'public', 'register.html')));
app.get('/reset-password.html', (req, res) => res.sendFile(path.join(__dirname, 'public', 'reset-password.html')));
app.get('/choose-organization.html', (req, res) => res.sendFile(path.join(__dirname, 'public', 'choose-organization.html')));

// â”€â”€ æ–°å¢ï¼šç”¨æˆ¶è³‡è¨Šç«¯é» â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
app.get('/api/user-info', async (req, res) => {
  try {
    const token = req.cookies.token;
    if (!token) {
      return res.status(401).json({ error: 'æœªç™»å…¥' });
    }

    const decoded = jwt.verify(token, JWT_SECRET);
    
    // ç²å–ç”¨æˆ¶è³‡æ–™
    const personRes = await fetch(`${FHIR_BASE}/Person/${decoded.id}`);
    const person = await handleFHIRResponse(personRes, 'fetch user info');
    
    const name = person.name?.[0]?.text || 'æœªå‘½åç”¨æˆ¶';
    const loginId = person.identifier?.find(i => i.system === LOGIN_ID_SYSTEM)?.value;
    const email = person.identifier?.find(i => i.system === EMAIL_SYSTEM)?.value;
    
    res.json({ 
      id: person.id,
      name,
      loginId,
      email,
      isAdmin: decoded.isAdmin || false
    });

  } catch (err) {
    console.error('[api/user-info] Error:', err);
    res.status(401).json({ error: 'ç²å–ç”¨æˆ¶è³‡è¨Šå¤±æ•—' });
  }
});

// â”€â”€ 1) Register â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
app.post('/api/person/register', async (req, res) => {
  let { name, loginId, email, phone, birthday, password } = req.body;
  
  // æ¸…ç†è¼¸å…¥
  name = sanitizeInput(name);
  loginId = sanitizeInput(loginId);
  email = sanitizeInput(email);
  phone = sanitizeInput(phone);
  birthday = sanitizeInput(birthday);
  
  // é©—è­‰å¿…è¦æ¬„ä½
  if (!name || !loginId || !email || !password) {
    return res.status(400).json({ error: 'ç¼ºå°‘å¿…è¦æ¬„ä½ï¼šå§“åã€ç™»å…¥IDã€é›»å­éƒµä»¶ã€å¯†ç¢¼' });
  }
  
  // é©—è­‰é›»å­éƒµä»¶æ ¼å¼
  if (!isValidEmail(email)) {
    return res.status(400).json({ error: 'é›»å­éƒµä»¶æ ¼å¼ä¸æ­£ç¢º' });
  }
  
  // é©—è­‰å¯†ç¢¼é•·åº¦
  if (password.length < 4) {
    return res.status(400).json({ error: 'å¯†ç¢¼è‡³å°‘éœ€è¦4å€‹å­—ç¬¦' });
  }
  
  // é©—è­‰ç™»å…¥IDæ ¼å¼ï¼ˆåªå…è¨±å­—æ¯æ•¸å­—ï¼‰
  if (!/^[a-zA-Z0-9_-]+$/.test(loginId)) {
    return res.status(400).json({ error: 'ç™»å…¥IDåªèƒ½åŒ…å«å­—æ¯ã€æ•¸å­—ã€ç ´æŠ˜è™Ÿå’Œä¸‹åŠƒç·š' });
  }

  try {
    // æª¢æŸ¥ loginId æ˜¯å¦å·²å­˜åœ¨
    const chkRes = await fetch(`${FHIR_BASE}/Person?identifier=${encodeURIComponent(LOGIN_ID_SYSTEM)}|${encodeURIComponent(loginId)}`);
    const chkData = await handleFHIRResponse(chkRes, 'check existing user');
    if (chkData.total > 0) return res.status(409).json({ error: 'Login ID å·²å­˜åœ¨' });

    // å»ºç«‹ Person
    const person = {
      resourceType: 'Person',
      name: [{ text: name }],
      ...(birthday && { birthday }),
      identifier: [
        { system: LOGIN_ID_SYSTEM, value: loginId },
        { system: EMAIL_SYSTEM, value: email },
        { system: PASSWORD_SYSTEM, value: await bcrypt.hash(password, 10) }
      ],
      telecom: [
        { system: 'email', value: email, use: 'home' },
        ...(phone ? [{ system: 'phone', value: phone, use: 'home' }] : [])
      ]
    };

    const personRes = await fetch(`${FHIR_BASE}/Person`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/fhir+json' },
      body: JSON.stringify(person)
    });

    const newPerson = await handleFHIRResponse(personRes, 'create Person');

    res.status(201).json({
      message: 'è¨»å†ŠæˆåŠŸï¼',
      personId: newPerson.id
    });

  } catch (err) {
    console.error('[api/person/register] Error:', err);
    res.status(500).json({ error: 'è¨»å†Šå¤±æ•—', detail: err.message });
  }
});

// â”€â”€ 2) Login â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
app.post('/api/login', async (req, res) => {
  const { loginId: input, password } = req.body;
  if (!input || !password) return res.status(400).json({ error: 'ç™»å…¥IDå’Œå¯†ç¢¼ç‚ºå¿…å¡«' });

  try {
    const url = `${FHIR_BASE}/Person?identifier=${encodeURIComponent(LOGIN_ID_SYSTEM)}|${encodeURIComponent(input)}`;
    const response = await fetch(url);
    const data = await handleFHIRResponse(response, 'login user lookup');
    
    if (data.total === 0) {
      return res.status(401).json({ error: 'ç”¨æˆ¶ä¸å­˜åœ¨æˆ–ç™»å…¥IDéŒ¯èª¤' });
    }

    const person = data.entry[0].resource;

    const hashEntry = person.identifier.find(i => i.system === PASSWORD_SYSTEM);
    if (!hashEntry) return res.status(500).json({ error: 'å¯†ç¢¼è³‡æ–™éºå¤±' });

    const isMatch = await bcrypt.compare(password, hashEntry.value);
    if (!isMatch) return res.status(401).json({ error: 'å¯†ç¢¼éŒ¯èª¤' });

    // æª¢æŸ¥æ˜¯å¦ç‚ºç®¡ç†å“¡
    const loginIdEntry = person.identifier.find(i => i.system === LOGIN_ID_SYSTEM);
    const isAdmin = loginIdEntry && loginIdEntry.value === "root";

    const token = jwt.sign({ 
      id: person.id,
      isAdmin: isAdmin,
      loginId: loginIdEntry?.value
    }, JWT_SECRET, { expiresIn: '8h' }); // å»¶é•·æœ‰æ•ˆæœŸç‚º 8 å°æ™‚
    
    // âœ… ä½¿ç”¨æ™ºæ…§ Cookie è¨­ç½®
    setSmartCookie(res, 'token', token, {
      httpOnly: true,
      maxAge: 8 * 3600000 // 8å°æ™‚
    });
    
    // è¨˜éŒ„æœƒè©±
    activeSessions.set(token, {
      personId: person.id,
      loginId: loginIdEntry?.value,
      isAdmin: isAdmin,
      timestamp: new Date().toISOString(),
      ip: req.ip
    });
    
    // æ¸…ç†èˆŠæœƒè©±
    cleanupOldSessions();
    
    res.json({ 
      message: 'ç™»å…¥æˆåŠŸ',
      personId: person.id,
      isAdmin: isAdmin,
      name: person.name?.[0]?.text || 'ç”¨æˆ¶'
    });

  } catch (err) {
    console.error('[api/login] Error:', err);
    res.status(500).json({ error: 'ç™»å…¥å¤±æ•—', detail: err.message });
  }
});

// æ¸…ç†èˆŠæœƒè©±å‡½æ•¸
const cleanupOldSessions = () => {
  const now = Date.now();
  const eightHoursAgo = now - (8 * 3600000);
  
  for (const [token, session] of activeSessions.entries()) {
    try {
      const decoded = jwt.verify(token, JWT_SECRET);
      const tokenTime = decoded.iat * 1000;
      
      if (tokenTime < eightHoursAgo) {
        activeSessions.delete(token);
      }
    } catch (err) {
      activeSessions.delete(token);
    }
  }
};

// â”€â”€ 3) Logout â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
app.post('/api/logout', (req, res) => {
  const token = req.cookies.token;
  
  if (token) {
    activeSessions.delete(token);
  }
  
  // æ¸…é™¤æ‰€æœ‰ç›¸é—œçš„ cookies
  res.clearCookie('token');
  res.clearCookie('selectedRole');
  
  res.json({ 
    message: 'ç™»å‡ºæˆåŠŸ',
    success: true 
  });
});

// â”€â”€ 4) ç®¡ç†å“¡æ¬Šé™æª¢æŸ¥ç«¯é» â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
app.get('/api/check-admin', async (req, res) => {
  try {
    const token = req.cookies.token;
    if (!token) {
      return res.status(401).json({ isAdmin: false, error: 'æœªç™»å…¥' });
    }

    const decoded = jwt.verify(token, JWT_SECRET);
    
    // ç›´æ¥å¾ token ä¸­è®€å–ç®¡ç†å“¡ç‹€æ…‹
    res.json({ 
      isAdmin: decoded.isAdmin || false,
      personId: decoded.id,
      loginId: decoded.loginId
    });

  } catch (err) {
    console.error('[api/check-admin] Error:', err);
    res.status(401).json({ isAdmin: false, error: 'Token ç„¡æ•ˆ' });
  }
});

// â”€â”€ 5) Get Practitioner Roles â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
app.get('/api/practitioner/roles', async (req, res) => {
  try {
    const token = req.cookies.token;
    console.log(`ğŸ” æª¢æŸ¥ token: ${token ? 'å­˜åœ¨' : 'ä¸å­˜åœ¨'}`);
    
    if (!token) {
      console.log('âŒ æ²’æœ‰æ‰¾åˆ° token cookie');
      return res.status(401).json({ error: 'Unauthorized - è«‹é‡æ–°ç™»å…¥' });
    }

    // é©—è­‰ token
    let decoded;
    try {
      decoded = jwt.verify(token, JWT_SECRET);
      console.log(`âœ… Token é©—è­‰æˆåŠŸï¼Œç”¨æˆ¶ ID: ${decoded.id}, ç®¡ç†å“¡: ${decoded.isAdmin}`);
    } catch (jwtError) {
      console.error('âŒ Token é©—è­‰å¤±æ•—:', jwtError.message);
      return res.status(401).json({ error: 'Invalid token - è«‹é‡æ–°ç™»å…¥' });
    }

    const { id: personId, isAdmin } = decoded;

    // å¦‚æœæ˜¯ç®¡ç†å“¡ï¼Œè¿”å›ç‰¹æ®Šçš„ç®¡ç†å“¡è§’è‰²
    if (isAdmin) {
      console.log('ğŸ‘‘ ç®¡ç†å“¡ç™»å…¥ï¼Œè¿”å›ç®¡ç†å“¡è§’è‰²');
      const adminRole = {
        practitionerRoleId: 'admin',
        practitionerId: 'admin',
        organizationId: 'system',
        organizationName: 'ç³»çµ±ç®¡ç†',
        jobTitle: 'ç³»çµ±ç®¡ç†å“¡',
        roleType: 'admin'
      };
      
      // âœ… ä½¿ç”¨æ™ºæ…§ Cookie è¨­ç½®
      setSmartCookie(res, 'selectedRole', JSON.stringify(adminRole), {
        httpOnly: false,
        maxAge: 8 * 3600000 // 8å°æ™‚
      });
      
      return res.json([adminRole]);
    }

    // éç®¡ç†å“¡çš„åŸæœ‰é‚è¼¯ä¿æŒä¸è®Š
    const personRes = await fetch(`${FHIR_BASE}/Person/${personId}`);
    const person = await handleFHIRResponse(personRes, 'fetch Person');

    const practitionerIds = (person.link || [])
      .map(l => l.target?.reference)
      .filter(ref => ref && ref.startsWith('Practitioner/'))
      .map(ref => ref.split('/')[1]);

    if (practitionerIds.length === 0) return res.json([]);

    const rolesMap = new Map();
    
    for (const pid of practitionerIds) {
      // ä½¿ç”¨ _include å’Œ _revinclude ä¾†ç²å–å®Œæ•´çš„ Organization è³‡è¨Š
      const roleRes = await fetch(
        `${FHIR_BASE}/PractitionerRole?practitioner=Practitioner/${pid}&_include=PractitionerRole:organization&_revinclude=Organization:partof`
      );
      const roleData = await handleFHIRResponse(roleRes, 'fetch PractitionerRole');

      // å»ºç«‹ Organization è³‡æºæ˜ å°„
      const organizationMap = new Map();
      (roleData.entry || []).forEach(entry => {
        if (entry.resource.resourceType === 'Organization') {
          organizationMap.set(entry.resource.id, entry.resource);
        }
      });

      (roleData.entry || []).forEach(e => {
        if (e.resource.resourceType !== 'PractitionerRole') return;

        const roleId = e.resource.id;
        if (rolesMap.has(roleId)) return;

        const title = e.resource.code?.[0]?.text || e.resource.code?.[0]?.coding?.[0]?.display || '';
        
        let roleType = 'other';
        const allCodeTexts = [
          title.toLowerCase(),
          ...(e.resource.code?.[0]?.coding || []).map(c => c.display?.toLowerCase() || ''),
          ...(e.resource.code?.[0]?.coding || []).map(c => c.code?.toLowerCase() || '')
        ].filter(Boolean);

        for (const text of allCodeTexts) {
          if (text.includes('é†«å¸«') || text.includes('é†«ç”Ÿ') || text.includes('doctor') || text.includes('physician')) {
            roleType = 'doctor';
            break;
          } else if (text.includes('è—¥å¸«') || text.includes('è—¥åŠ‘å¸«') || text.includes('pharmacist')) {
            roleType = 'pharmacist';
            break;
          } else if (text.includes('è­·ç†å¸«') || text.includes('è­·å£«') || text.includes('nurse')) {
            roleType = 'nurse';
            break;
          } else if (text.includes('åŠ©ç†') || text.includes('assistant')) {
            roleType = 'assistant';
            break;
          }
        }

        if (roleType === 'other' && title) {
          roleType = title;
        }

        // æ”¹é€²ï¼šæ­£ç¢ºç²å– Organization åç¨±
        let organizationName = 'æœªçŸ¥æ©Ÿæ§‹';
        let organizationId = 'unknown';
        
        if (e.resource.organization && e.resource.organization.reference) {
          const orgReference = e.resource.organization.reference;
          organizationId = orgReference.split('/')[1];
          
          // å¾ included è³‡æºä¸­ç²å– Organization åç¨±
          if (organizationMap.has(organizationId)) {
            const orgResource = organizationMap.get(organizationId);
            organizationName = orgResource.name || organizationName;
          } else {
            // å¦‚æœæ²’æœ‰åœ¨ included ä¸­æ‰¾åˆ°ï¼Œå˜—è©¦ç›´æ¥æŸ¥è©¢
            organizationName = e.resource.organization.display || organizationId;
          }
        }

        rolesMap.set(roleId, {
          practitionerRoleId: roleId,
          practitionerId: pid,
          organizationId: organizationId,
          organizationName: organizationName,
          jobTitle: title,
          roleType
        });
      });
    }

    const roles = Array.from(rolesMap.values());

    // å¦‚æœåªæœ‰ä¸€å€‹è§’è‰² â†’ è‡ªå‹•é¸å®š
    if (roles.length === 1) {
      const r = roles[0];
      
      // âœ… ä½¿ç”¨æ™ºæ…§ Cookie è¨­ç½®
      setSmartCookie(res, 'selectedRole', JSON.stringify({
        organizationId: r.organizationId,
        practitionerRoleId: r.practitionerRoleId,
        practitionerId: r.practitionerId,
        roleType: r.roleType
      }), {
        httpOnly: false,
        maxAge: 8 * 3600000 // 8å°æ™‚
      });
    }

    console.log(`âœ… è¿”å› ${roles.length} å€‹è§’è‰²`);
    
    res.json(roles);

  } catch (err) {
    console.error('[api/practitioner/roles] Error:', err);
    if (err.name === 'JsonWebTokenError') {
      return res.status(401).json({ error: 'Invalid token' });
    }
    res.status(500).json({ error: err.message });
  }
});

// â”€â”€ 6) Select Role â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
app.post('/api/practitioner/select-role', async (req, res) => {
  try {
    const token = req.cookies.token;
    if (!token) {
      console.log('âŒ select-role: æ²’æœ‰ token');
      return res.status(401).json({ error: 'Unauthorized' });
    }

    const { id: personId } = jwt.verify(token, JWT_SECRET);
    const { organizationId, practitionerRoleId, practitionerId, roleType } = req.body;
    if (!organizationId || !practitionerRoleId || !practitionerId || !roleType) {
      return res.status(400).json({ error: 'Missing data' });
    }

    // å–å¾— Person
    const personRes = await fetch(`${FHIR_BASE}/Person/${personId}`);
    const person = await handleFHIRResponse(personRes, 'fetch Person');

    // åªä¿ç•™ç•¶å‰é¸æ“‡çš„ Practitionerï¼Œé¿å…é‡è¤‡
    const practitionerRef = `Practitioner/${practitionerId}`;
    person.link = [{ target: { reference: practitionerRef } }];

    // æ›´æ–° Person
    const updateRes = await fetch(`${FHIR_BASE}/Person/${personId}`, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/fhir+json' },
      body: JSON.stringify(person),
    });
    await handleFHIRResponse(updateRes, 'update Person links');

    // âœ… ä½¿ç”¨æ™ºæ…§ Cookie è¨­ç½®
    setSmartCookie(res, 'selectedRole', JSON.stringify({
      organizationId,
      practitionerRoleId,
      practitionerId,
      roleType
    }), {
      httpOnly: false,
      maxAge: 8 * 3600000 // 8å°æ™‚
    });

    res.json({ message: 'Role selected successfully' });

  } catch (err) {
    console.error('[api/practitioner/select-role] Error:', err);
    res.status(500).json({ error: err.message });
  }
});

// â”€â”€ 7) Password Reset â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
app.post('/api/request-reset', async (req, res) => {
  const { loginId } = req.body;
  
  const cleanLoginId = sanitizeInput(loginId);
  
  if (!cleanLoginId) {
    return res.status(400).json({ error: 'ç™»å…¥IDç‚ºå¿…å¡«' });
  }

  try {
    const response = await fetch(`${FHIR_BASE}/Person?identifier=${encodeURIComponent(LOGIN_ID_SYSTEM)}|${encodeURIComponent(cleanLoginId)}`);
    const data = await handleFHIRResponse(response, 'find user for password reset');
    
    if (data.total === 0) {
      console.log(`[å¯†ç¢¼é‡è¨­] æœªæ‰¾åˆ°ç™»å…¥ID: ${cleanLoginId}`);
      // å‡ºæ–¼å®‰å…¨è€ƒæ…®ï¼Œä¸å‘Šè¨´ç”¨æˆ¶ç™»å…¥IDæ˜¯å¦å­˜åœ¨
      return res.json({ 
        message: 'å¦‚æœè©²ç™»å…¥IDå­˜åœ¨ï¼Œé‡è¨­é€£çµå·²å¯„é€åˆ°è¨»å†Šä¿¡ç®±' 
      });
    }

    const person = data.entry[0].resource;
    
    const emailEntry = person.identifier.find(i => i.system === EMAIL_SYSTEM);
    if (!emailEntry) {
      return res.status(400).json({ error: 'è©²å¸³è™Ÿæœªè¨­å®šé›»å­éƒµä»¶' });
    }

    const email = emailEntry.value;
    const personName = person.name?.[0]?.text || '';
    
    const resetToken = jwt.sign({ 
      id: person.id, 
      type: 'password_reset',
      timestamp: Date.now(),
      email: email
    }, JWT_SECRET, { expiresIn: '15m' }); // 15åˆ†é˜æœ‰æ•ˆæœŸ
    
    // ç™¼é€é‡ç½®éƒµä»¶
    const emailResult = await sendResetEmail(email, resetToken, personName);
    
    const responseData = { 
      message: 'å¦‚æœè©²ç™»å…¥IDå­˜åœ¨ï¼Œé‡è¨­é€£çµå·²å¯„é€åˆ°è¨»å†Šä¿¡ç®±' 
    };
    
    // é–‹ç™¼æ¨¡å¼ä¸‹æä¾›é‡è¨­é€£çµ
    if (emailResult.developmentMode) {
      responseData.developmentInfo = 'é–‹ç™¼æ¨¡å¼ï¼šéƒµä»¶æœªå¯¦éš›ç™¼é€ï¼Œè«‹æŸ¥çœ‹æ§åˆ¶å°ç²å–é‡è¨­é€£çµ';
      responseData.resetLink = emailResult.resetLink;
    }
    
    res.json(responseData);

  } catch (err) {
    console.error('[api/request-reset] Error:', err);
    // å‡ºæ–¼å®‰å…¨è€ƒæ…®ï¼Œç¸½æ˜¯è¿”å›ç›¸åŒçš„è¨Šæ¯
    res.json({ 
      message: 'å¦‚æœè©²ç™»å…¥IDå­˜åœ¨ï¼Œé‡è¨­é€£çµå·²å¯„é€åˆ°è¨»å†Šä¿¡ç®±' 
    });
  }
});

// â”€â”€ 8) Reset Password â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
app.post('/api/reset-password', async (req, res) => {
  const { token, newPassword } = req.body;
  
  const cleanToken = sanitizeInput(token);
  const cleanPassword = sanitizeInput(newPassword);
  
  if (!cleanToken || !cleanPassword) {
    return res.status(400).json({ error: 'Tokenå’Œæ–°å¯†ç¢¼ç‚ºå¿…å¡«' });
  }

  if (cleanPassword.length < 4) {
    return res.status(400).json({ error: 'å¯†ç¢¼è‡³å°‘éœ€è¦4å€‹å­—ç¬¦' });
  }

  try {
    const decoded = jwt.verify(cleanToken, JWT_SECRET);
    
    // âœ… æª¢æŸ¥ä»¤ç‰Œæ˜¯å¦å·²è¢«ä½¿ç”¨
    if (usedTokens.has(cleanToken)) {
      return res.status(400).json({ error: 'æ­¤é‡è¨­é€£çµå·²è¢«ä½¿ç”¨ï¼Œè«‹ç”³è«‹æ–°çš„é‡è¨­é€£çµ' });
    }
    
    if (decoded.type !== 'password_reset') {
      return res.status(400).json({ error: 'ç„¡æ•ˆçš„é‡è¨­ä»¤ç‰Œ' });
    }
    
    // æª¢æŸ¥ token æ˜¯å¦éæœŸï¼ˆ15åˆ†é˜ï¼‰
    const currentTime = Date.now();
    const tokenTime = decoded.timestamp || decoded.iat * 1000;
    if (currentTime - tokenTime > 15 * 60000) { // 15åˆ†é˜
      return res.status(400).json({ error: 'é‡è¨­é€£çµå·²éæœŸï¼ˆ15åˆ†é˜ï¼‰ï¼Œè«‹ç”³è«‹æ–°çš„é‡è¨­é€£çµ' });
    }

    // ç²å–ç”¨æˆ¶è³‡æ–™
    const personRes = await fetch(`${FHIR_BASE}/Person/${decoded.id}`);
    const person = await handleFHIRResponse(personRes, 'fetch Person for password reset');
    
    // æ‰¾åˆ°å¯†ç¢¼è­˜åˆ¥ç¢¼ä¸¦æ›´æ–°
    const passwordIdentifier = person.identifier.find(i => i.system === PASSWORD_SYSTEM);
    const hashedPassword = await bcrypt.hash(cleanPassword, 10);
    
    if (passwordIdentifier) {
      passwordIdentifier.value = hashedPassword;
    } else {
      person.identifier.push({
        system: PASSWORD_SYSTEM,
        value: hashedPassword
      });
    }

    // âœ… è¨˜éŒ„æœ€å¾Œé‡è¨­æ™‚é–“
    const lastResetIdentifier = person.identifier.find(i => i.system === LAST_RESET_TIME_SYSTEM);
    const currentTimeISO = new Date().toISOString();
    
    if (lastResetIdentifier) {
      lastResetIdentifier.value = currentTimeISO;
    } else {
      person.identifier.push({
        system: LAST_RESET_TIME_SYSTEM,
        value: currentTimeISO
      });
    }

    // æ›´æ–° Person
    const updateRes = await fetch(`${FHIR_BASE}/Person/${decoded.id}`, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/fhir+json' },
      body: JSON.stringify(person)
    });

    await handleFHIRResponse(updateRes, 'update password');

    // âœ… å°‡ä»¤ç‰Œæ¨™è¨˜ç‚ºå·²ä½¿ç”¨
    usedTokens.add(cleanToken);
    
    // âœ… å®šæœŸæ¸…ç†å·²ä½¿ç”¨çš„ä»¤ç‰Œï¼ˆé¿å…å…§å­˜æ´©æ¼ï¼‰
    setTimeout(() => {
      usedTokens.delete(cleanToken);
    }, 3600000); // 1å°æ™‚å¾Œæ¸…ç†

    res.json({ 
      message: 'å¯†ç¢¼é‡è¨­æˆåŠŸ',
      success: true
    });
    
  } catch (err) {
    console.error('[api/reset-password] Error:', err);
    
    if (err.name === 'JsonWebTokenError') {
      return res.status(400).json({ error: 'ç„¡æ•ˆæˆ–éæœŸçš„é‡è¨­é€£çµ' });
    }
    
    if (err.name === 'TokenExpiredError') {
      return res.status(400).json({ error: 'é‡è¨­é€£çµå·²éæœŸï¼ˆ15åˆ†é˜ï¼‰ï¼Œè«‹ç”³è«‹æ–°çš„é‡è¨­é€£çµ' });
    }
    
    res.status(500).json({ error: 'é‡è¨­å¯†ç¢¼å¤±æ•—ï¼Œè«‹ç¨å¾Œå†è©¦' });
  }
});

// â”€â”€ 9) æ–°å¢ï¼šç®¡ç†å“¡åŠŸèƒ½ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// ç²å–æ‰€æœ‰ç”¨æˆ¶åˆ—è¡¨ï¼ˆç®¡ç†å“¡å°ˆç”¨ï¼‰
app.get('/api/admin/users', async (req, res) => {
  try {
    // é©—è­‰ç®¡ç†å“¡æ¬Šé™
    const token = req.cookies.token;
    if (!token) return res.status(401).json({ error: 'æœªæˆæ¬Š' });
    
    const decoded = jwt.verify(token, JWT_SECRET);
    if (!decoded.isAdmin) {
      return res.status(403).json({ error: 'éœ€è¦ç®¡ç†å“¡æ¬Šé™' });
    }

    // ç²å–æ‰€æœ‰ Person
    const personRes = await fetch(`${FHIR_BASE}/Person?_count=100`);
    const data = await handleFHIRResponse(personRes, 'fetch all users');
    
    const users = (data.entry || []).map(entry => {
      const person = entry.resource;
      const loginId = person.identifier?.find(i => i.system === LOGIN_ID_SYSTEM)?.value;
      const email = person.identifier?.find(i => i.system === EMAIL_SYSTEM)?.value;
      
      return {
        id: person.id,
        name: person.name?.[0]?.text || 'æœªå‘½å',
        loginId,
        email,
        telecom: person.telecom || [],
        active: true,
        lastLogin: activeSessions.get(token)?.timestamp || null
      };
    });

    res.json({ users, total: users.length });

  } catch (err) {
    console.error('[api/admin/users] Error:', err);
    res.status(500).json({ error: err.message });
  }
});

// â”€â”€ å¥åº·æª¢æŸ¥ç«¯é» â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
app.get('/health', (req, res) => {
  res.json({ 
    status: 'ok', 
    timestamp: new Date().toISOString(),
    environment: process.env.NODE_ENV || 'development',
    serverHostname: process.env.SERVER_HOSTNAME || '203.64.84.209',
    cors: 'enabled',
    secureCookies: 'disabled (å…¼å®¹å…§å¤–ç¶²)',
    activeSessions: activeSessions.size,
    usedTokens: usedTokens.size
  });
});

// â”€â”€ æœƒè©±èª¿è©¦ç«¯é» â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
app.get('/api/debug/sessions', (req, res) => {
  const sessions = Array.from(activeSessions.entries()).map(([token, session]) => ({
    token: token.substring(0, 10) + '...',
    ...session
  }));
  
  res.json({
    totalSessions: activeSessions.size,
    sessions: sessions,
    currentCookies: req.cookies,
    clientIP: req.ip,
    protocol: req.protocol,
    secure: req.secure
  });
});

// â”€â”€ Cookie æ¸¬è©¦ç«¯é» â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
app.get('/api/test-cookie', (req, res) => {
  // æ¸¬è©¦è¨­ç½® cookie
  setSmartCookie(res, 'test_cookie', 'test_value_' + Date.now(), {
    httpOnly: false,
    maxAge: 60000 // 1åˆ†é˜
  });
  
  res.json({ 
    message: 'Cookie å·²è¨­ç½®',
    cookiesSent: req.cookies,
    clientInfo: {
      ip: req.ip,
      origin: req.headers.origin,
      userAgent: req.headers['user-agent']
    }
  });
});

// â”€â”€ Error Handling Middleware â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
app.use((error, req, res, next) => {
  console.error('Unhandled error:', error);
  
  if (error.name === 'JsonWebTokenError') {
    return res.status(401).json({ error: 'Invalid token' });
  }
  
  if (error.name === 'TokenExpiredError') {
    return res.status(401).json({ error: 'Token expired' });
  }
  
  // CORS éŒ¯èª¤è™•ç†
  if (error.message.includes('ä¸å…è¨±çš„ä¾†æº')) {
    return res.status(403).json({ error: 'CORS: ä¸å…è¨±çš„ä¾†æº' });
  }
  
  res.status(500).json({ 
    error: 'Internal server error',
    ...(process.env.NODE_ENV === 'development' && { detail: error.message })
  });
});

// â”€â”€ 404 è™•ç† â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
app.use((req, res) => {
  res.status(404).json({ error: 'Endpoint not found' });
});

// â”€â”€ Start Server â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const PORT = process.env.PORT || 3000;

// å•Ÿå‹•ä¼ºæœå™¨
app.listen(PORT, '0.0.0.0', () => {
  console.log(`
==============================================
âœ… ä¼ºæœå™¨é‹è¡Œä¸­
ğŸ“± æœ¬åœ°è¨ªå•ï¼šhttp://localhost:${PORT}
ğŸŒ å¤–éƒ¨è¨ªå•ï¼šhttp://203.64.84.209:${PORT}
âš™ï¸  ç’°å¢ƒï¼š${process.env.NODE_ENV || 'development'}
ğŸ”— FHIR ä¼ºæœå™¨ï¼š${FHIR_BASE}
ğŸª Cookie ç­–ç•¥ï¼šæ™ºæ…§è¨­ç½®ï¼ˆsecure=falseï¼Œå…¼å®¹å…§å¤–ç¶²ï¼‰
ğŸ” ç®¡ç†å“¡åŠŸèƒ½ï¼šå·²å•Ÿç”¨ï¼ˆroot ç”¨æˆ¶ï¼‰
ğŸ“§ éƒµä»¶æœå‹™ï¼š${process.env.SMTP_USER ? 'å·²é…ç½®' : 'æœªé…ç½®'}
==============================================
ğŸ’¡ æç¤ºï¼š
1. Cookie secure è¨­ç‚º false ä»¥å…¼å®¹ HTTP
2. æ”¯æŒå…§å¤–ç¶²åŒæ™‚è¨ªå•
3. Token æœ‰æ•ˆæœŸï¼š8å°æ™‚
4. é‡è¨­ä»¤ç‰Œæœ‰æ•ˆæœŸï¼š15åˆ†é˜
==============================================
  `);
});
